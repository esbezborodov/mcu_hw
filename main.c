/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include "main.h"
#include <string.h>

device_t device;

static inline void __print(uint8_t sym) { GPIOC->ODR = sym; }

void device_print(device_t* state)
{
	switch (state->counter)
	{
	case 0:
		state->indicator = PRINT_0;  // 0
		break;
	case 1:
		state->indicator = PRINT_1;  // 1
		break;
	case 2:
		state->indicator = PRINT_2;  // 2
		break;
	case 3:
		state->indicator = PRINT_3;  // 3
		break;
	case 4:
		state->indicator = PRINT_4;  // 4
		break;
	case 5:
		state->indicator = PRINT_5;  // 5
		break;
	case 6:
		state->indicator = PRINT_6;  // 6
		break;
	case 7:
		state->indicator = PRINT_7;  // 7
		break;
	case 8:
		state->indicator = PRINT_8;  // 8
		break;
	case 9:
		state->indicator = PRINT_9;  // 9
		break;
	case 10:
		state->indicator = PRINT_A;  // A
        break;
    case 11:
    	state->indicator = PRINT_B;  // B
        break;
    case 12:
    	state->indicator = PRINT_C;  // C
        break;
    case 13:
    	state->indicator = PRINT_D;  // D
        break;
    case 14:
    	state->indicator = PRINT_E;  // E
        break;
    case 15:
    	state->indicator = PRINT_F;  // F
        break;
	}
	__print(state->indicator);
}

void device_init(device_t* state)
{
	// indicator
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
	GPIOC->CRL &=~GPIO_CRL_CNF0;
	GPIOC->CRL |= GPIO_CRL_MODE0;
	GPIOC->CRL &=~GPIO_CRL_CNF1;
	GPIOC->CRL |= GPIO_CRL_MODE1;
	GPIOC->CRL &=~GPIO_CRL_CNF2;
	GPIOC->CRL |= GPIO_CRL_MODE2;
	GPIOC->CRL &=~GPIO_CRL_CNF3;
	GPIOC->CRL |= GPIO_CRL_MODE3;
	GPIOC->CRL &=~GPIO_CRL_CNF4;
	GPIOC->CRL |= GPIO_CRL_MODE4;
	GPIOC->CRL &=~GPIO_CRL_CNF5;
	GPIOC->CRL |= GPIO_CRL_MODE5;
	GPIOC->CRL &=~GPIO_CRL_CNF6;
	GPIOC->CRL |= GPIO_CRL_MODE6;
	// encoder
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	GPIOA->CRL &= ~(GPIO_CRL_CNF5 | GPIO_CRL_MODE5);
	GPIOA->CRL |= GPIO_CRL_MODE5_1;
	GPIOA->CRH &= ~(GPIO_CRH_MODE8 | GPIO_CRH_MODE9);
	GPIOA->CRH &= ~(GPIO_CRH_CNF8 | GPIO_CRH_CNF9);
	GPIOA->CRH |= (GPIO_CRH_CNF8_0 | GPIO_CRH_CNF9_0);
	// tmr
	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
	TIM1->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);
	TIM1->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
	TIM1->SMCR |= TIM_SMCR_SMS_0;
	TIM1->CCMR1 |= (TIM_CCMR1_IC1F_0 | TIM_CCMR1_IC1F_1);
	TIM1->ARR = 17;
	TIM1->CR1 |= (TIM_CR1_CEN | TIM_CR1_ARPE);
	//state
	state->counter = 0;
}

void device_read(device_t* state)
{
    if (TIM1->CNT > 16) TIM1->CNT = 16;
    if (TIM1->CNT < 1)  TIM1->CNT = 1;
    state->counter = (uint8_t)TIM1->CNT - 1;
}

void clk_init(void)
{
	RCC->CR |= RCC_CR_HSION;
	while(!(RCC->CR & RCC_CR_HSIRDY)){};
	FLASH->ACR |= FLASH_ACR_PRFTBE;
	FLASH->ACR &= ~FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
	RCC->CFGR &= ~RCC_CFGR_PLLSRC;
	RCC->CFGR |= RCC_CFGR_PLLMULL16;
	RCC->CR |= RCC_CR_PLLON;
	while((RCC->CR & RCC_CR_PLLRDY) == 0) {};
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
}

int main(void)
{
	clk_init();
	device_init(&device);
    while(true)
    {
    	device_read(&device);
    	device_print(&device);


    }
}
